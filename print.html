<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mina Fungible Token Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Deploy and interact with custom fungible tokens on Mina.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">2.</strong> API</a></li><li class="chapter-item expanded "><a href="deploy.html"><strong aria-hidden="true">3.</strong> Deploy</a></li><li class="chapter-item expanded "><a href="token_operations.html"><strong aria-hidden="true">4.</strong> Token Operations</a></li><li class="chapter-item expanded "><a href="use_in_zk_app.html"><strong aria-hidden="true">5.</strong> Use in ZkApp</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mina Fungible Token Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MinaFoundation/mina-fungible-token" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Mina natively supports custom tokens
(<a href="https://github.com/MinaProtocol/MIPs/blob/main/MIPS/mip-zkapps.md#token-mechanics">MIP-4</a>). Each
account on Mina can correspond to a custom token.</p>
<p>To create a new token, one creates a smart contract, which becomes the manager for the token, and
uses that contract to set the rules around how the token can be minted, burned and transferred. The
contract may also set a token symbol. Uniqueness is not enforced for token names. Instead the public
key of the contract is used to derive the token's unique identifier.</p>
<h2 id="show-me-the-code"><a class="header" href="#show-me-the-code">SHOW ME THE CODE</a></h2>
<p>The
<a href="https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/e2e.eg.ts"><code>mina-fungible-token</code> repo's e2e example</a>
showcases the entire lifecycle of a token.</p>
<p>After running <code>npm i mina-fungible-token</code>, import the <code>FungibleToken</code> contract and deploy it like
so.</p>
<pre><code class="language-ts">const token = new FungibleToken(contract.publicKey)

const deployTx = await Mina.transaction({
  sender: deployer.publicKey,
  fee,
}, () =&gt; {
  AccountUpdate.fundNewAccount(deployer.publicKey, 1)
  token.deploy({
    owner: owner.publicKey,
    supply: UInt64.from(10_000_000_000_000),
    symbol: &quot;abc&quot;,
    src: &quot;https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/e2e.eg.ts&quot;,
  })
})
await deployTx.prove()
deployTx.sign([deployer.privateKey, contract.privateKey])
await deployTx.send()
</code></pre>
<blockquote>
<p>Note: this example assumes that <code>contract</code> and <code>deployer</code> are valid key pairs in scope.</p>
</blockquote>
<h2 id="how"><a class="header" href="#how">How?</a></h2>
<p>How is this custom token mechanism implemented in Mina?</p>
<h3 id="token-manager"><a class="header" href="#token-manager">Token Manager</a></h3>
<p>The token manager account is a contract with the following capabilities.</p>
<ul>
<li>Set a token symbol (also called token name) for its token. Uniqueness is not enforced for token
names because the public key of the manager account is used to derive a unique identifier for each
token.</li>
<li>Mint new tokens. The zkApp updates an account's balance by adding the newly created tokens to it.
You can send minted tokens to any existing account in the network.</li>
<li>Burn tokens (the opposite of minting). Burning tokens deducts the balance of a certain address by
the specified amount. A zkApp cannot burn more tokens than the specified account has.</li>
<li>Send tokens between two accounts. Any account can initiate a transfer, and the transfer must be
approved by a Token Manager zkApp (see <a href="introduction.html#approval-mechanism">Approval mechanism</a>).</li>
</ul>
<h3 id="token-account"><a class="header" href="#token-account">Token Account</a></h3>
<p>Token accounts are like regular accounts, but they hold a balance of a specific custom token instead
of MINA. A token account is created from an existing account and is specified by a public key <em>and</em>
a token id.</p>
<p>Token accounts are specific for each type of custom token, so a single public key can have many
different token accounts.</p>
<p>A token account is automatically created for a public key whenever an existing account receives a
transaction denoted with a custom token.</p>
<blockquote>
<p>[!IMPORTANT] When a token account is created for the first time, an account creation fee must be
paid the same as creating a new standard account.</p>
</blockquote>
<h3 id="token-id"><a class="header" href="#token-id">Token ID</a></h3>
<p>Token ids are unique identifiers that distinguish between different types of custom tokens. Custom
token identifiers are globally unique across the entire network.</p>
<p>Token ids are derived from a Token Manager zkApp. Use <code>deriveTokenId()</code> function to get id of a
token.</p>
<h3 id="approval-mechanism"><a class="header" href="#approval-mechanism">Approval mechanism</a></h3>
<p>Sending tokens between two accounts must be approved by a Token Manager zkApp. This can be done with
<code>approveBase()</code> method of the custom token standard reference implementation.</p>
<p>If you customize the <code>transfer()</code> function or constructing <code>AccountUpdate</code>s for sending tokens
manually, don't forget to call <code>approveBase()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-overview"><a class="header" href="#api-overview">API overview</a></h1>
<p>The token standard implementation is a Token Manager zkApp that is split in 2 parts: low-level and
high-level one.</p>
<p>The low-level implementation is included in <code>o1js</code> library <code>TokenContract</code> abstract class. See the
overview in the o1js
<a href="https://docs.minaprotocol.com/zkapps/o1js/custom-tokens">Custom Tokens tutorial</a></p>
<blockquote>
<p>[!WARNING] Please note that this is a beta release. The implementation will change soon. The API
may also change in future.</p>
</blockquote>
<p>The high-level part inherits from the <code>TokenContract</code> class and has following user-facing features:</p>
<h2 id="on-chain-state-decimals-and-deploy-arguments"><a class="header" href="#on-chain-state-decimals-and-deploy-arguments">On-chain State, <code>decimals</code> and deploy arguments</a></h2>
<p>The on-chain state is defined as follows:</p>
<pre><code class="language-ts">@state(PublicKey) public owner = State&lt;PublicKey&gt;();
@state(UInt64) public supply = State&lt;UInt64&gt;();
@state(UInt64) public circulating = State&lt;UInt64&gt;();
</code></pre>
<ul>
<li>
<p><code>owner</code> is set on deployment, and some of token functionality requires an admin signature.</p>
<p>If you want to implement admin-only method, just call <code>this.ensureOwnerSignature()</code> helper in the
method you want to protect.</p>
</li>
<li>
<p><code>supply</code> defines a maximum amount of tokens to exist. It is set on deployment and can be modified
with <code>setSupply()</code> function (can be called by admin only)</p>
</li>
<li>
<p><code>circulating</code> tracks the total amount in circulation. When new tokens are minted, the
<code>circulating</code> increases by an amount minted.</p>
</li>
<li>
<p>The <code>decimals</code> is a constant, that defines where to place the decimal comma in the token amounts.</p>
</li>
<li>
<p>The <code>deploy()</code> function requires <code>owner</code> and <code>supply</code> to be passed as parameters.</p>
</li>
<li>
<p>Along with state variables initial values, the <code>deploy()</code> function also takes <code>symbol</code> (to set
<code>account.tokenSymbol</code>) and <code>src</code> (to set <code>account.zkappUri</code>)</p>
</li>
</ul>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Methods that can be called only by admin are:</p>
<pre><code class="language-ts">mint(address: PublicKey, amount: UInt64)
setTotalSupply(amount: UInt64)
setOwner(owner: PublicKey)
</code></pre>
<p>Transfer and burn functionality is available by following methods:</p>
<pre><code class="language-ts">transfer(from: PublicKey, to: PublicKey, amount: UInt64)
burn(from: PublicKey, amount: UInt64)
</code></pre>
<p>Helper methods for reading state variables and account balance</p>
<pre><code class="language-ts">getBalanceOf(address: PublicKey)
getSupply()
getCirculating()
getDecimals()
</code></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>On each token operation, the event is emitted. The events are declared as follows:</p>
<pre><code class="language-ts">events = {
  SetOwner: PublicKey,
  Mint: MintEvent,
  SetSupply: UInt64,
  Burn: BurnEvent,
  Transfer: TransferEvent,
}

class MintEvent extends Struct({
  recipient: PublicKey,
  amount: UInt64,
}) {}

class BurnEvent extends Struct({
  from: PublicKey,
  amount: UInt64,
}) {}

class TransferEvent extends Struct({
  from: PublicKey,
  to: PublicKey,
  amount: UInt64,
}) {}
</code></pre>
<p>That completes a review of a fungible token.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy"><a class="header" href="#deploy">Deploy</a></h1>
<p>To create a token manager smart contract, inherit your smart contract from base custom token
implementation, or use the <code>FungibleToken</code> directly</p>
<pre><code class="language-ts">import { FungibleToken } from &quot;mina-fungible-token&quot;

class MyToken extends FungibleToken {}
</code></pre>
<blockquote>
<p>[!NOTE] If you inherit from <code>FungibleToken</code> to override some functionality, you will need to
compile both parent and child contracts to be able to prove code for both of them</p>
</blockquote>
<p>To deploy a token manager contract, create and compile the token contract instance, then create,
prove and sign the deploy transaction:</p>
<pre><code class="language-ts">await FungibleToken.compile()
await MyToken.compile()

const {
  privateKey: tokenKey,
  publicKey: tokenAddress,
} = PrivateKey.randomKeypair()
const token = new MyToken(tokenAddress)

// paste the private key of the deployer and admin account here
const deployerKey = PrivateKey.fromBase58(&quot;...&quot;)
const ownerKey = PrivateKey.fromBase58(&quot;...&quot;)
const owner = PublicKey.fromPrivateKey(ownerKey)
const deployer = PublicKey.fromPrivateKey(deployerKey)

const supply = UInt64.from(21_000_000)
const symbol = &quot;MYTKN&quot;
const src = &quot;https://github.com/MinaFoundation/mina-fungible-token/blob/main/FungibleToken.ts&quot;

const fee = 1e8

const tx = await Mina.transaction({ sender: deployer, fee }, () =&gt; {
  AccountUpdate.fundNewAccount(deployer, 1)
  token.deploy(owner, supply, symbol, src)
})

tx.sign([deployerKey, tokenKey])
await tx.prove()
await tx.send()
</code></pre>
<p>For this and following samples to work, make sure you have enough funds on deployer and admin
accounts.</p>
<p>Refer to
<a href="https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/e2e.eg.ts">examples/e2e.eg.ts</a>
to see executable end to end example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-operations"><a class="header" href="#token-operations">Token Operations</a></h1>
<p>In this section, we will explore the various token operations represented by the standard, which
include:</p>
<ul>
<li>Minting</li>
<li>Burning</li>
<li>Transferring between users</li>
</ul>
<h2 id="mint-tokens"><a class="header" href="#mint-tokens">Mint tokens</a></h2>
<p>To mint tokens to some address:</p>
<pre><code class="language-ts">// paste the address where you want to mint tokens to
const mintTo = PublicKey.fromBase58(&quot;...&quot;)
const mintAmount = UInt64.from(1000)

const tx = await Mina.transaction({ sender: owner, fee }, () =&gt; {
  // comment this line if a receiver already has token account
  AccountUpdate.fundNewAccount(owner, 1)
  token.mint(mintTo, mintAmount)
})

tx.sign([tokenAdminKey])
await tx.prove()
await tx.send()
</code></pre>
<blockquote>
<p>[!IMPORTANT] When a token account is created for the first time, an account creation fee must be
paid the same as creating a new standard account.</p>
</blockquote>
<h2 id="burn-tokens"><a class="header" href="#burn-tokens">Burn tokens</a></h2>
<p>To burn tokens owned by some address:</p>
<pre><code class="language-ts">// paste the address where you want to burn tokens from
const burnFrom = PublicKey.fromBase58(&quot;...&quot;)
const burnAmount = UInt64.from(1000)

const tx = await Mina.transaction({ sender: burnFrom, fee }, () =&gt; {
  token.burn(burnFrom, burnAmount)
})

tx.sign([burnFromKey])
await tx.prove()
await tx.send()
</code></pre>
<h2 id="transfer-tokens-between-user-accounts"><a class="header" href="#transfer-tokens-between-user-accounts">Transfer tokens between user accounts</a></h2>
<p>To transfer tokens between two user accounts:</p>
<pre><code class="language-ts">// paste the private key of the sender and the address of the receiver
const sendFrom = PublicKey.fromBase58(&quot;...&quot;)
const sendFromKey = Private.fromPublicKey(sendFrom)
const sendTo = PublicKey.fromBase58(&quot;...&quot;)

const sendAmount = UInt64.from(1)

const tx = await Mina.transaction({ sender: sendFrom, fee }, () =&gt; {
  token.transfer(sendFrom, sendTo, sendAmount)
})
tx.sign([sendFromKey])
await tx.prove()
await tx.send()
</code></pre>
<h2 id="fetch-token-balance-of-the-account"><a class="header" href="#fetch-token-balance-of-the-account">Fetch token balance of the account</a></h2>
<p>To get token balance of some account:</p>
<pre><code class="language-ts">// paste the address of the account you want to read balance of
const anyAccount = PublicKey.fromBase58(&quot;...&quot;)
const balance = token.getBalanceOf(anyAccount)
</code></pre>
<p>Refer to
<a href="https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/e2e.eg.ts">examples/e2e.eg.ts</a>
to see executable end to end example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-a-zkapp"><a class="header" href="#use-in-a-zkapp">Use in a ZkApp</a></h1>
<p>With zkApps, you can also build smart contracts that interact with tokens. For example, a simple
escrow contract, where tokens can be deposited to and withdrawn from.</p>
<h2 id="escrow-contract-code"><a class="header" href="#escrow-contract-code">Escrow contract code</a></h2>
<p>Interacting with tokens from a zkApp is as simple as writing off-chain code (same code like in
previous chapter is executed from within zkApp methods):</p>
<pre><code class="language-ts">export class TokenEscrow extends SmartContract {
  @state(PublicKey)
  tokenAddress = State&lt;PublicKey&gt;()
  @state(UInt64)
  total = State&lt;UInt64&gt;()

  deploy(args: DeployArgs &amp; { tokenAddress: PublicKey }) {
    super.deploy(args)
    this.tokenAddress.set(args.tokenAddress)
    this.total.set(UInt64.zero)
  }

  @method
  deposit(from: PublicKey, amount: UInt64) {
    const token = new FungibleToken(this.tokenAddress.getAndRequireEquals())
    token.transfer(from, this.address, amount)
    const total = this.total.getAndRequireEquals()
    this.total.set(total.add(amount))
  }

  @method
  withdraw(to: PublicKey, amount: UInt64) {
    const token = new FungibleToken(this.tokenAddress.getAndRequireEquals())
    const total = this.total.getAndRequireEquals()
    total.greaterThanOrEqual(amount)
    this.total.set(total.sub(amount))
    token.transfer(this.address, to, amount)
  }
}
</code></pre>
<h2 id="interacting-with-token-escrow"><a class="header" href="#interacting-with-token-escrow">Interacting with token escrow</a></h2>
<p>Refer to
<a href="https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/escrow.eg.ts">examples/escrow.eg.ts</a>
to see executable <code>TokenEscrow</code> example.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
