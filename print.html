<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mina Fungible Token Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Deploy and interact with custom fungible tokens on Mina.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">2.</strong> API</a></li><li class="chapter-item expanded "><a href="deploy.html"><strong aria-hidden="true">3.</strong> Deploy</a></li><li class="chapter-item expanded "><a href="token_operations.html"><strong aria-hidden="true">4.</strong> Token Operations</a></li><li class="chapter-item expanded "><a href="use_in_zk_app.html"><strong aria-hidden="true">5.</strong> Use in ZkApp</a></li><li class="chapter-item expanded "><a href="limitations.html"><strong aria-hidden="true">6.</strong> Design Limitations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mina Fungible Token Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MinaFoundation/mina-fungible-token" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This document describes how to work with the fungible token standard on Mina. The corresponding code
can be found on <a href="https://github.com/MinaFoundation/mina-fungible-token">github</a>, or installed as an
<a href="https://www.npmjs.com/package/mina-fungible-token">npm package</a>.</p>
<p>The fungible token standard uses Mina's native support for custom tokens (see
<a href="https://github.com/MinaProtocol/MIPs/blob/main/MIPS/mip-zkapps.md#token-mechanics">MIP-4</a>). An
account on Mina can be created to hold either Mina, or a custom token.</p>
<p>To create a new token, one creates a smart contract, which becomes the owner for the token, and uses
that contract to set the rules around how the token can be minted, burned and transferred. The
contract may also set a token symbol. Uniqueness is not enforced for token names. Instead the public
key of the contract is used to derive the token's unique identifier.</p>
<p>The token contract defines the behavior of the token -- how tokens can be minted, burned,
transferred, etc. The fungible token standard consists of a smart contract that is suitable for
fungible tokens.</p>
<h2 id="show-me-the-code"><a class="header" href="#show-me-the-code">SHOW ME THE CODE</a></h2>
<p>The
<a href="https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/e2e.eg.ts"><code>mina-fungible-token</code> repo's e2e example</a>
showcases the entire lifecycle of a token.</p>
<p>After running <code>npm i mina-fungible-token</code>, import the <code>FungibleToken</code> and <code>FungibleTokenAdmin</code>
contracts and deploy them:</p>
<pre><code class="language-ts">const token = new FungibleToken(contract.publicKey)
const adminContract = new FungibleTokenAdmin(admin.publicKey)

const deployTx = await Mina.transaction({
  sender: deployer,
  fee,
}, async () =&gt; {
  AccountUpdate.fundNewAccount(deployer, 3)
  await adminContract.deploy({ adminPublicKey: admin.publicKey })
  await token.deploy({
    symbol: &quot;abc&quot;,
    src: &quot;https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/e2e.eg.ts&quot;,
  })
  await token.initialize(
    admin.publicKey,
    UInt8.from(9),
    Bool(false),
  )
})
await deployTx.prove()
deployTx.sign([deployer.key, contract.privateKey, admin.privateKey])
await deployTx.send()
</code></pre>
<blockquote>
<p>Note: this example assumes that <code>contract</code> and <code>deployer</code> are valid key pairs in scope.</p>
</blockquote>
<h2 id="how"><a class="header" href="#how">How?</a></h2>
<p>How is this custom token mechanism implemented in Mina?</p>
<h3 id="token-owner-account"><a class="header" href="#token-owner-account">Token Owner Account</a></h3>
<p>The token owner account is a contract with the following capabilities.</p>
<ul>
<li>Set a token symbol (also called token name) for its token. Uniqueness is not enforced for token
names because the public key of the owner account is used to derive a unique identifier for each
token.</li>
<li>Mint new tokens. The zkApp updates an account's balance by adding the newly created tokens to it.
You can send minted tokens to any existing account in the network.</li>
<li>Burn tokens (the opposite of minting). Burning tokens deducts the balance of a certain address by
the specified amount. A zkApp cannot burn more tokens than the specified account has.</li>
<li>Send tokens between two accounts. There are two ways to initiate a transfer: either, the token
owner can create the account updates directly (via the <code>transfer</code> method), or the account updates
can be created externally, and then approved by the token owner (see
<a href="introduction.html#approval-mechanism">Approval mechanism</a>).</li>
</ul>
<h3 id="token-account"><a class="header" href="#token-account">Token Account</a></h3>
<p>Token accounts are like regular accounts, but they hold a balance of a specific custom token instead
of MINA. A token account is specified by a public key <em>and</em> a token id.</p>
<p>Token accounts are specific for each type of custom token, so a single public key can have many
different token accounts.</p>
<p>A token account is automatically created for a public key whenever an existing account receives a
transaction denoted with a custom token.</p>
<blockquote>
<p>[!IMPORTANT] When a token account is created for the first time, an account creation fee must be
paid the same as creating a new standard account.</p>
</blockquote>
<h3 id="token-id"><a class="header" href="#token-id">Token ID</a></h3>
<p>Token ids are unique identifiers that distinguish between different types of custom tokens. Custom
token identifiers are globally unique across the entire network.</p>
<p>Token ids are derived from a Token Owner account. Use the <code>deriveTokenId()</code> function to get the id
of a token.</p>
<h3 id="approval-mechanism"><a class="header" href="#approval-mechanism">Approval mechanism</a></h3>
<p>Sending tokens between two accounts must be approved by a Token Owner zkApp. This can be done with
the <code>approveBase()</code> method of the custom token standard reference implementation.</p>
<blockquote>
<p>[!IMPORTANT] When manually constructing <code>AccountUpdate</code>s, make sure to order then appropriately in
the call to <code>approveBase()</code>. The contract will not allow flash minting, i.e., tokens cannot be
received by an account before they have been sent from an account.</p>
</blockquote>
<p>[!NOTE] The number of <code>AccountUpdate</code>s that you can pass to <code>approveBase()</code> is limited by the base
token contract. The current limit is 9.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-overview"><a class="header" href="#api-overview">API overview</a></h1>
<p>The token standard implementation provides a smart contract <code>FungibleToken</code> that can be deployed as
the token owner for a new token. It provides all the user facing functionality that is expected of a
fungible token: creating, transferring, and destroying tokens, as well as querying balances and the
overall amount of tokens.</p>
<p>Using the standard means using this particular, unmodified, contract. The reason that altering the
contract is considered deviating from the standard is the off-chain execution model of MINA: a third
party (wallet, exchange, etc.) that wants to integrate a token needs to have access to and execute
the code of the token owner contract in order to interact with the token. Agreeing on one particular
implementation reduces the burden of integration significantly.</p>
<p>In order to allow for some customization without changing the token owner contract, we delegate some
functionality to a secondary admin contract, called <code>FungibleTokenAdmin</code>. This contract controls
access to privileged operations such as minting, pausing/resuming transfers, or changing the admin
contract itself. This construction allows you to set the rules for monetary expansion, without
changing the token owner contract itself. Since the admin contract will only be called from methods
of the token contract that are not meant to be called by regular users, the code of the admin
contract does not need to be integrated into wallets or other third party applications.</p>
<p>is a Token Manager zkApp that is split in 2 parts: low-level and high-level one.</p>
<h2 id="the-fungibletoken-contract"><a class="header" href="#the-fungibletoken-contract">The <code>FungibleToken</code> contract</a></h2>
<h2 id="on-chain-state-and-deploy-arguments"><a class="header" href="#on-chain-state-and-deploy-arguments">On-chain State and deploy arguments</a></h2>
<p>The on-chain state is defined as follows:</p>
<pre><code class="language-ts">@state(UInt8) decimals = State&lt;UInt8&gt;()
@state(PublicKey) admin = State&lt;PublicKey&gt;()
@state(UInt64) private circulating = State&lt;UInt64&gt;()
@state(Bool) paused = State&lt;Bool&gt;()
</code></pre>
<p>The <code>deploy()</code> function takes as arguments</p>
<ul>
<li>A string to use as the token symbol</li>
<li>A string pointing to the source code of the contract -- when following the standard, this should
point to the source of the standard implementation on github</li>
</ul>
<p>Immediately after deploying the contract -- ideally, in the same transaction -- the contract needs
to be initialized via the <code>initialize()</code> method. Its arguments are</p>
<ul>
<li>The public key of the account that the admin contract has been deployed to</li>
<li>A <code>UInt8</code> for the number of decimals</li>
<li>A <code>Bool</code> to determine whether the token contract should start in paused mode. whether token
transfers should be enabled immediately. If set to <code>Bool(true)</code>, the token contract will be in a
paused state initially, and the <code>resume()</code> method will need to be called before tokens can be
minted or transferred. This is safer if you have a non-atomic deploy (i.e., if you do not have the
admin contract deployed in the same transaction as the token contract is itself is deployed and
initialized).</li>
</ul>
<p>This method initializes the state of the contract. Initially, the circulating supply is set to zero,
as no tokens have been created yet.</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>The user facing methods of <code>FungibleToken</code> are</p>
<pre><code class="language-ts">@method.returns(AccountUpdate) async burn(from: PublicKey, amount: UInt64): Promise&lt;AccountUpdate&gt;

@method async transfer(from: PublicKey, to: PublicKey, amount: UInt64)
@method async approveBase(updates: AccountUpdateForest): Promise&lt;void&gt;
@method.returns(UInt64) async getBalanceOf(address: PublicKey): Promise&lt;UInt64&gt;
@method.returns(UInt64) async getCirculating(): Promise&lt;UInt64&gt;
@method async updateCirculating()
@method.returns(UInt8) async getDecimals(): Promise&lt;UInt8&gt;
</code></pre>
<p>The following methods call the admin account for permission, and are not supposed to be called by
regular users</p>
<pre><code class="language-ts">@method async setAdmin(admin: PublicKey)
@method.returns(AccountUpdate) async mint(recipient: PublicKey, amount: UInt64): Promise&lt;AccountUpdate&gt;
@method async pause()
@method async resume()
</code></pre>
<h3 id="minting-burning-and-keeping-track-of-the-circulating-supply"><a class="header" href="#minting-burning-and-keeping-track-of-the-circulating-supply">Minting, burning, and keeping track of the circulating supply</a></h3>
<p>In order to allow multiple minting/burning transactions in a single block, we do not tally the
circulating supply as part of the contract state. Instead, we use a special account, the balance of
which always corresponds to the total number of tokens in other accounts. The balance of this
account is updated in the <code>mint()</code> and <code>burn()</code> methods. Transfers to and from this account are not
possible. The <code>getCirculating()</code> method reports the balance of the account.</p>
<p>Note that if you want to require certain limits on the circulation, you should express your
constraints using <code>requireBetween()</code> rather than <code>requireEquals()</code>. This is more robust against
minting or burning transactions in the same block invalidating your preconditions.</p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>The following events are emitted from <code>FungibleToken</code> when appropriate:</p>
<pre><code class="language-ts">events = {
  SetAdmin: SetAdminEvent,
  Pause: PauseEvent,
  Mint: MintEvent,
  Burn: BurnEvent,
  BalanceChange: BalanceChangeEvent,
}

export class SetAdminEvent extends Struct({
  adminKey: PublicKey,
}) {}

export class PauseEvent extends Struct({
  isPaused: Bool,
}) {}

class MintEvent extends Struct({
  recipient: PublicKey,
  amount: UInt64,
}) {}

class BurnEvent extends Struct({
  from: PublicKey,
  amount: UInt64,
}) {}

export class BalanceChangeEvent extends Struct({
  address: PublicKey,
  amount: Int64,
}) {}
</code></pre>
<p>Note that <code>MintEvent</code>, <code>BurnEvent</code>, and <code>BalanceChangeEvent</code> each signal that the balance of an
account changes. The difference is that <code>MintEvent</code> and <code>BurnEvent</code> are emitted when tokens are
minted/burned, and <code>BalanceChangeEvent</code> is emitted when a transaction takes tokens from some
addresses, and sends them to others.</p>
<p>[!NOTE] Note that <code>MintEvent</code>, <code>BurnEvent</code>, and <code>BalanceChangeEvent</code> events can be emitted with
<code>amount = 0</code>. If you want to track &quot;true&quot; mints/burns/transfers (for example, to maintain a list of
depositors), you will need to filter for non-zero values of <code>amount</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy"><a class="header" href="#deploy">Deploy</a></h1>
<p>Setting up a new fungible token requires three steps: deploying an admin contract, deploying the
token contract itself, and initializing the contract</p>
<h2 id="deploying-an-admin-contract"><a class="header" href="#deploying-an-admin-contract">Deploying an admin contract</a></h2>
<p>The first step is deploying the admin contract via its <code>deploy()</code> function.</p>
<p>The admin contract handles permissions for privileged actions, such as minting. It is called by the
token contract whenever a user tries to do a privileged action.</p>
<p>The benefit of separating those permissions out into a separate contract is that it allows changing
the permission logic without changing the original token contract. That is important because third
parties that want to integrate a specific token will need the contract code for that token. If most
tokens use the standard token contract, and only modify the admin contract, the integration burden
for third parties is reduced significantly.</p>
<p>If you want to change your admin contract, you can write a contract that <code>extends SmartContract</code> and
<code>implements FungibleTokenAdminBase</code>.</p>
<p>[!NOTE] Note that if you want to use a custom admin contract, you should write the admin contract
from scratch. Inheriting from <code>FungibleTokenAdmin</code> and overwriting specific methods might not work.
You can find an example of a custom admin contract in <code>FungibleToken.test.ts</code>.</p>
<p>The <code>initialize()</code> method of <code>FungibleToken</code> takes as one argument the address of the admin
contract. If you have written your own admin contract, you will also need to set
<code>FungibleToken.AdminContract</code> to that class.</p>
<p>[!NOTE] If you do not use the <code>FungibleToken</code> class as is, third parties that want to integrate your
token will need to use your custom contract as well.</p>
<p>[!NOTE] The <code>deploy()</code> function of the admin contract sets permissions such that the admin contract
can only be upgraded/replaced in case of a breaking update of the chain, and prevents changing the
permissions of the account the contract is deployed to. That way, users can trust that the code of
the admin contract will not change arbitrarily. If you write your own admin contract, set
permissions accordingly.</p>
<h3 id="admin-contract-and-centralization"><a class="header" href="#admin-contract-and-centralization">Admin Contract and Centralization</a></h3>
<p>The default admin contract uses a single keypair. That is not ideal, as it introduces a single point
of failure.</p>
<p>Higher levels of security can be achieved by utilizing a decentralized governance or multi-sig
scheme, and it is recommended to do so.</p>
<p>Any user purchasing a token should investigate the key management practices of the token deployer
and validate the token contract permissions as one should with any o1js application. In particular,
they should check that</p>
<ul>
<li>The verification keys of the admin and token contract are as expected</li>
<li>Both admin and token contract have set the permission such that the verification key can only be
set after a breaking update of the network</li>
<li>Both the admin and token contract have set the permissions to change permissions set to
<code>impossible</code></li>
<li>The deployment transaction of the token contract has not been changed to skip the <code>isNew</code> check
that has been introduced in <a href="https://github.com/o1-labs/o1js/issues/1439">Issue 1439</a>. If a
malicious deployer were to skip this test, they could mint tokens for themselves before deployment
of the token contract.</li>
</ul>
<h2 id="initializing-and-deploying-the-token-contract"><a class="header" href="#initializing-and-deploying-the-token-contract">Initializing and deploying the token contract</a></h2>
<p>Next, the token contract needs to be deployed, via its <code>deploy()</code> function.</p>
<p>After being deployed, the token contract needs to be initialized, by calling the <code>init()</code> function
and <code>initialize()</code> method. Those make sure that the contract state is initialized, create an account
on the chain that will be used to track the current circulation of the token, set all permissions on
the account of the token contract and the account that's tracking the total circulation.</p>
<p>[!NOTE] All three steps above can be carried out in a single transaction, or in separate
transactions. It is highly recommended to have a single transaction with all three steps.</p>
<p>[!NOTE] Unless you have a very good reason, please use one transaction that deploys the admin
contract, deploys the token contract, and calls <code>initialize()</code> on the token contract.</p>
<p>[!NOTE] Each of the three steps requires funding a new account on the chain via
<code>AccountUpdate.fundNewAccount</code>.</p>
<p>[!NOTE] If you use separate transactions for deploying the admin contract and deploying and
initializing the token contract, you should start the token contract in paused mode, and only call
<code>resume()</code> after you have verified that the admin contract has been successfully deployed.</p>
<p>Refer to
<a href="https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/e2e.eg.ts">examples/e2e.eg.ts</a>
to see executable end to end example.</p>
<h2 id="a-note-on-upgradeability"><a class="header" href="#a-note-on-upgradeability">A Note on Upgradeability</a></h2>
<p>By default, the token and admin contract have permissions set so that they cannot be upgraded,
except in case of a non-backwards compatible hard fork of Mina (see
<a href="https://docs.minaprotocol.com/zkapps/writing-a-zkapp/feature-overview/permissions#example-impossible-to-upgrade">Mina documentation on upgradeability</a>).
This is to ensure that the rules around the token are not changed after the token is deployed.</p>
<p>Depending on the maturity of your project, that might or might not be what you want. Disallowing
contract updates gives a strong guarantee to token holders that the rules around the token will not
change. For example, if the admin contract ensures a limited supply of the token, or forbids minting
new tokens after a certain date, then a change of that contract can undo those guarantees. This
might be the right thing to do if you have figured out exactly how you want the token to behave, and
are sure that you will not make any changes in the future.</p>
<p>If you do want to reserve the possibility to make changes in the future, then you should alter the
<code>deploy()</code> functions to set the account permissions for the token and admin contracts to allow
changes to the verification key. If you do that, you will probably also want to allow future changes
to the account permissions, to eventually disallow further changes to the verification key.</p>
<p>If you are looking to acquire fungible tokens, you should consider that if the deployer used more
permissive account permissions for the contracts, they might change the contracts in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-operations"><a class="header" href="#token-operations">Token Operations</a></h1>
<p>In this section, we will explore the various token operations represented by the standard, which
include:</p>
<ul>
<li>Minting</li>
<li>Burning</li>
<li>Transferring between users</li>
</ul>
<h2 id="mint-tokens"><a class="header" href="#mint-tokens">Mint tokens</a></h2>
<p>To mint tokens to some address:</p>
<pre><code class="language-ts">// paste the address where you want to mint tokens to
const mintTo = PublicKey.fromBase58(&quot;...&quot;)
const mintAmount = UInt64.from(1000)

const mintTx = await Mina.transaction({
  sender: owner,
  fee,
}, async () =&gt; {
  // remove this line if a receiver already has token account
  AccountUpdate.fundNewAccount(owner, 1)
  await token.mint(mintTo, new UInt64(2e9))
})
mintTx.sign([owner.privateKey, admin.privateKey])
await mintTx.prove()
await mintTx.send()
</code></pre>
<blockquote>
<p>[!IMPORTANT] When a token account is created for the first time, an account creation fee must be
paid the same as creating a new standard account.</p>
</blockquote>
<h2 id="burn-tokens"><a class="header" href="#burn-tokens">Burn tokens</a></h2>
<p>To burn tokens owned by some address:</p>
<pre><code class="language-ts">// paste the address where you want to burn tokens from
const burnFrom = PublicKey.fromBase58(&quot;...&quot;)
const burnAmount = UInt64.from(1000)

const tx = await Mina.transaction({ sender: burnFrom, fee }, () =&gt; {
  token.burn(burnFrom, burnAmount)
})

tx.sign([burnFromKey])
await tx.prove()
await tx.send()
</code></pre>
<h2 id="transfer-tokens-between-user-accounts"><a class="header" href="#transfer-tokens-between-user-accounts">Transfer tokens between user accounts</a></h2>
<p>To transfer tokens between two user accounts:</p>
<pre><code class="language-ts">// paste the private key of the sender and the address of the receiver
const sendFrom = PublicKey.fromBase58(&quot;...&quot;)
const sendFromKey = Private.fromPublicKey(sendFrom)
const sendTo = PublicKey.fromBase58(&quot;...&quot;)

const sendAmount = UInt64.from(1)

const tx = await Mina.transaction({ sender: sendFrom, fee }, () =&gt; {
  token.transfer(sendFrom, sendTo, sendAmount)
})
tx.sign([sendFromKey])
await tx.prove()
await tx.send()
</code></pre>
<h2 id="fetch-token-balance-of-the-account"><a class="header" href="#fetch-token-balance-of-the-account">Fetch token balance of the account</a></h2>
<p>To get token balance of some account:</p>
<pre><code class="language-ts">// paste the address of the account you want to read balance of
const anyAccount = PublicKey.fromBase58(&quot;...&quot;)
const balance = token.getBalanceOf(anyAccount)
</code></pre>
<p>Refer to
<a href="https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/e2e.eg.ts">examples/e2e.eg.ts</a>
to see executable end to end example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-a-zkapp"><a class="header" href="#use-in-a-zkapp">Use in a ZkApp</a></h1>
<p>With zkApps, you can also build smart contracts that interact with tokens. For example, a simple
escrow contract, where tokens can be deposited to and withdrawn from.</p>
<h2 id="escrow-contract-code"><a class="header" href="#escrow-contract-code">Escrow contract code</a></h2>
<p>Interacting with tokens from a zkApp is as simple as writing off-chain code (same code like in
previous chapter is executed from within zkApp methods):</p>
<pre><code class="language-ts">export class TokenEscrow extends SmartContract {
  @state(PublicKey)
  tokenAddress = State&lt;PublicKey&gt;()
  @state(UInt64)
  total = State&lt;UInt64&gt;()

  deploy(args: DeployArgs &amp; { tokenAddress: PublicKey }) {
    super.deploy(args)
    this.tokenAddress.set(args.tokenAddress)
    this.total.set(UInt64.zero)
  }

  @method
  deposit(from: PublicKey, amount: UInt64) {
    const token = new FungibleToken(this.tokenAddress.getAndRequireEquals())
    token.transfer(from, this.address, amount)
    const total = this.total.getAndRequireEquals()
    this.total.set(total.add(amount))
  }

  @method
  withdraw(to: PublicKey, amount: UInt64) {
    const token = new FungibleToken(this.tokenAddress.getAndRequireEquals())
    const total = this.total.getAndRequireEquals()
    total.greaterThanOrEqual(amount)
    this.total.set(total.sub(amount))
    token.transfer(this.address, to, amount)
  }
}
</code></pre>
<h2 id="interacting-with-token-escrow"><a class="header" href="#interacting-with-token-escrow">Interacting with token escrow</a></h2>
<p>Refer to
<a href="https://github.com/MinaFoundation/mina-fungible-token/blob/main/examples/escrow.eg.ts">examples/escrow.eg.ts</a>
to see executable <code>TokenEscrow</code> example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations-of-the-current-design"><a class="header" href="#limitations-of-the-current-design">Limitations of the Current Design</a></h1>
<p>The design of having one standard implementation of the token contract, and custom admin contracts,
allows for some flexibility, but there are some remaining limitations.</p>
<ol>
<li>
<p>Since token transfers should not depend on custom code, the <code>transfer()</code> and <code>approveBase()</code>
methods do not call into the admin contract. Consequently, custom transfer logic is not
supported.</p>
<p>Thus, token implementations will struggle to implement the following features:</p>
<ol>
<li>Fee on transfer. For examples, see
<a href="https://github.com/d-xo/weird-erc20?tab=readme-ov-file#fee-on-transfer">here</a>.</li>
<li>Token blacklists or whitelists. For examples, see
<a href="https://github.com/d-xo/weird-erc20?tab=readme-ov-file#tokens-with-blocklists">here</a>.</li>
<li>Circuit-breaking or transfer amount limits. For examples, see
<a href="https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-large-approvals--transfers">here</a>.</li>
</ol>
</li>
<li>
<p>Custom burn logic is not supported.</p>
<p>Many applications may wish to maintain some invariant related to the total supply. For instance,
a <code>wMina</code> token contract's admin would have a mechanism to lock or release <code>Mina</code> in return for
minting or burning <code>wMina</code>. This would currently be implemented by the <code>wMina</code> admin contract
having a method which calls burn on behalf of the user. However, this would only maintain the
invariant <code>wMina supply &gt;= locked Mina</code>, rather than strict equality.</p>
<p>This type of invariant is generally of interest to any token representing a share of some wrapped
assets.</p>
</li>
<li>
<p>Custom <code>balanceOf()</code> logic is not supported:</p>
<ol>
<li>Rebasable (like
<a href="https://github.com/lidofinance/lido-dao/blob/5fcedc6e9a9f3ec154e69cff47c2b9e25503a78a/contracts/0.4.24/StETH.sol#L166-L168">stEth</a>)
tokens may be difficult to implement. For more examples, see
<a href="https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops">here</a>.</li>
</ol>
</li>
</ol>
<p>In the future, Mina Foundation and the community might develop more flexible versions of the token
implementation that get around some or all of those limitations. That might involve additional
hooks, possibly with flags in the main token contract state that determine whether a custom contract
should be called or not. But for now, these limitations remain, and token developers should be aware
of them.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
